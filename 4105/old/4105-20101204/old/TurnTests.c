#pragma config(Hubs,  S1, HTMotor, HTMotor, HTServo, none)
#pragma config(Motor, mtr_S1_C1_1, motorD, tmotorNormal, /*PIDControl*/openLoop, encoder)
#pragma config(Motor, mtr_S1_C1_2, motorE, tmotorNormal, /*PIDControl*/openLoop, encoder)
#pragma config(Motor, mtr_S1_C2_1, intake, tmotorNormal, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.

int encoderD, encoderE;

void initializeRobot()
{
  // Place code here to sinitialize servos to starting positions.
  // Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.
  bFloatDuringInactiveMotorPWM = false;
  /*
  nMotorPIDSpeedCtrl[motorD] = mtrSpeedReg;
  nMotorPIDSpeedCtrl[motorE] = mtrSpeedReg;
  nMaxRegulatedSpeed12V = 750;
  */
  return;
}

/*
task view()
{
  int encoderD, encoderE;
  while(true)
  {
    encoderD = nMotorEncoder[motorD];
    encoderE = nMotorEncoder[motorE];
    wait1Msec(20);
  }
}
*/

void rightTurn()
{
  int turn = 750;
  nMotorEncoder[motorE] = 0;  //clear the TETRIX encoders in motors D and E
  nMotorEncoder[motorD] = 0;
  while (abs(nMotorEncoder[motorE])  < turn ||
         abs(nMotorEncoder[motorD]) < turn)
  {
    motor[motorE] = 30;
    motor[motorD] = 30;
    encoderD = nMotorEncoder[motorD];
    encoderE = nMotorEncoder[motorE];
  }

  motor[motorE] = 0; //turn both motors off
  motor[motorD] = 0;
}

void leftTurn()
{
  int turn = 750;
  nMotorEncoder[motorE] = 0;  //clear the TETRIX encoders in motors D and E
  nMotorEncoder[motorD] = 0;
  while (abs(nMotorEncoder[motorD]) < turn ||
         abs(nMotorEncoder[motorE]) < turn)
  {
    motor[motorE] = 30;
    motor[motorD] = 30;
    encoderD = nMotorEncoder[motorD];
    encoderE = nMotorEncoder[motorE];
  }

  motor[motorE] = 0; //turn both motors off
  motor[motorD] = 0;
}

void turnInPlaceRight()
{
  int turn = 1550;
  nMotorEncoder[motorE] = 0;  //clear the TETRIX encoders in motors D and E
  nMotorEncoder[motorD] = 0;
  while (abs(nMotorEncoder[motorE])  < turn)
  {
    motor[motorE] = 30;
    motor[motorD] = -30;
    encoderD = nMotorEncoder[motorD];
    encoderE = nMotorEncoder[motorE];
  }

  motor[motorE] = 0; //turn both motors off
  motor[motorD] = 0;
}

task main()
{
  initializeRobot();

  //waitForStart(); // Wait for the beginning of autonomous phase.

  //StartTask(view);

  nMotorEncoder[motorE] = 0;  //clear the TETRIX encoders in motors D and E
  nMotorEncoder[motorD] = 0;

  motor[motorE] = 0; //turn both motors off
  motor[motorD] = 0;

  wait1Msec(1000);

  encoderD = nMotorEncoder[motorD];
  encoderE = nMotorEncoder[motorE];

  wait1Msec(500);

  /*
  leftTurn();

  motor[intake] = -30;

  wait1Msec(5000);

  motor[intake] = 0;
  */
  //turnInPlaceRight();

  leftTurn();

  wait1Msec(500);

  rightTurn();
}
