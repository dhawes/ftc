#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Motor,  mtr_S1_C1_1, motorD, tmotorNormal, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2, motorE, tmotorNormal, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_1, intake, tmotorNormal, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//#pragma config(Servo,  srvo_S1_C3_1, wheelieBar1, tServoStandard)
//#pragma config(Servo,  srvo_S1_C3_2, wheelieBar2, tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.
#include "Autonomous.h"

void rightTurn();
void move(int distance, int speed);

/**
 * Initialize robot.
 */
void initializeRobot()
{
  // Place code here to sinitialize servos to starting positions.
  // Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.
  //servo[wheelieBar1] = 0;
  //servo[wheelieBar2] = 0;
  //bFloatDuringInactiveMotorPWM = false;

  return;
}

/**
 *
 */
task main()
{
  initializeRobot();

  waitForStart(); // Wait for the beginning of autonomous phase.

  nMotorEncoder[motorE] = 0;  //clear the TETRIX encoders in motors D and E
  nMotorEncoder[motorD] = 0;

  motor[motorE] = 0; //turn both motors off
  motor[motorD] = 0;

  wait1Msec(1000);

  rightTurn();
  wait1Msec(600);

  move(4000, 30);
  wait1Msec(600);
}

/**
 * Make a right turn.
 */
void rightTurn()
{
  nMotorEncoder[motorE] = 0;
  nMotorEncoder[motorD] = 0;
  while (abs(nMotorEncoder[motorE]) < RIGHT_TURN_ENCODER ||
         abs(nMotorEncoder[motorD]) < RIGHT_TURN_ENCODER)
  {
    motor[motorE] = TURN_SPEED;
    motor[motorD] = TURN_SPEED * -1;
  }
  motor[motorE] = 0;
  motor[motorD] = 0;
  nMotorEncoder[motorE] = 0;
  nMotorEncoder[motorD] = 0;
}

/**
 * Move the provided distance at the provided motor speed.
 *
 * distance -- the distance in encoder counts
 * speed    -- the motor speed (positive == forwards, negative == reverse
 */
void move(int distance, int speed)
{
  while (abs(nMotorEncoder[motorD]) < distance ||
         abs(nMotorEncoder[motorE]) < distance)
  {
    motor[motorE] = speed;
    motor[motorD] = speed;
  }
  motor[motorE] = 0;
  motor[motorD] = 0;
  nMotorEncoder[motorE] = 0;
  nMotorEncoder[motorD] = 0;
}
